using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Text.RegularExpressions;
using System.Xml;

/*
 *  Name:
 *  Type:
 *  Description:
 *  Arguments:
 */

// NOTE:
//   Exit code '0' means finished normally
//   Exit code '1' means finished help screen
//   Exit code '6' means updated from GitHub
//   Exit code '99' means error occured

namespace searchsploit
{
    /*
     *  Name: Service
     *  Type: Class
     *  Description: This class will be used to itemize a service when parsing nmap xml files
     *  Arguments: None
     */
    public class Service
    {
        // Service Class Attributes
        private String Product;
        private String Version;

        /*
         *  Name: Service
         *  Type: Constructor
         *  Description: This constructor is used to initiate a blank Service object
         *  Arguments: None
         */
        public Service()
        {
            this.Product = null;
            this.Version = null;
        }
        /*
         *  Name: Service
         *  Type: Constructor
         *  Description: This constructor is used to initiate a Service object with the Product and Version attributes being populated
         *  Arguments: String product, String version
         */
        public Service(String product, String version)
        {
            if (product == "")
            {
                this.Product = null;
            }
            else
            {
                this.Product = product;
            }
            if (version == "")
            {
                this.Version = null;
            }
            else
            {
                this.Version = version;
            }
        }

        public String ProductAttribute
        {
            get { return this.Product; }
            set { this.Product = value; }
        }
        public String VersionAttribute
        {
            get { return this.Version; }
            set { this.Version = value; }
        }
    }
    /*
     *  Name: Host
     *  Type: Class
     *  Description: This class will be used to itemize every host in an nmap xml file
     *  Arguments: None
     */
    public class Host
    {
        // Host Class Attributes
        private String Address;
        private List<Service> Services = new List<Service>();
        /*
         *  Name:
         *  Type:
         *  Description:
         *  Arguments:
         */
        public Host() { }
        /*
         *  Name:
         *  Type:
         *  Description:
         *  Arguments:
         */
        public Host(String address)
        {
            this.Address = address;
        }

        public String AddressAttribute
        {
            get { return this.Address; }
            set { this.Address = value; }
        }

        public List<Service> ServicesAttribute
        {
            get { return this.Services; }
            set { this.Services = value; }
        }
    }
    /*
     *  Name:
     *  Type:
     *  Description:
     *  Arguments:
     */
    class Program
    {
        // Variables to be used in the Program Class
        static int id = 0, file = 1, description = 2, col2 = 35, col1, numberOfResults = 0;
        static bool caseSensitivity = false, verbose = false, weblink = false, edbid = false, colour = true, filepath = true, nmap = false;
        static String binaryPath = AppDomain.CurrentDomain.BaseDirectory, csvPath = binaryPath+"files.csv";
        static List<String> terms = new List<String>();
        static List<Host> HostList = new List<Host>();
        /*
         *  Name: UpdateCSV
         *  Type: Function
         *  Description: This function is intended to update the archive 
         *  Arguments: None
         */
        public static int UpdateCSV()
        {
            try {
                String URL = @"https://github.com/offensive-security/exploit-database/archive/master.zip";
                String FileName = @"master.zip";

                if (Directory.Exists(binaryPath+"platforms")) { Directory.Delete(binaryPath + "platforms", true); }
                if (File.Exists(binaryPath + "files.csv")) { File.Delete(binaryPath + "files.csv"); }
                if (Directory.Exists(binaryPath + "exploit-database-master")) { Directory.Delete(binaryPath + "exploit-database-master", true); }
                if (File.Exists(binaryPath + "master.zip")) { File.Delete(binaryPath + "master.zip"); }

                WebClient myWebClient = new WebClient();
                myWebClient.DownloadFile(URL, binaryPath+FileName);

                ZipFile.ExtractToDirectory(binaryPath + FileName, binaryPath + ".");
                Directory.Move(binaryPath + @"exploit-database-master\platforms", binaryPath + "platforms");
                File.Move(binaryPath + @"exploit-database-master\files.csv", binaryPath + "files.csv");
                Directory.Delete(binaryPath + "exploit-database-master", true);
                File.Delete(binaryPath + "master.zip");

                Console.WriteLine("[*] Update finished.");
                return 6;
            }
            catch
            {
                Console.WriteLine("Error... Update could not be completed");
                return 99;
            }
        }
        /*
         *  Name: printHeader
         *  Type: Function
         *  Description: This function prints the header of the application depending on the given command line arguments
         *  Arguments: None
         */
        public static void printHeader()
        {
            drawline();
            if (weblink)
            {
                Console.WriteLine("{0,-" + col1 + "} | {1}", "Exploit Title", "URL");
                Console.WriteLine("{0,-" + col1 + "} | {1}", "", "");
            }
            else if (edbid)
            {
                Console.WriteLine("{0,-" + col1 + "} | {1}", "Exploit Title", "EDB-ID");
                Console.WriteLine("{0,-" + col1 + "} | {1}", "", "");
            }
            else
            {
                Console.WriteLine("{0,-" + col1 + "} | {1}", "Exploit Title", "Path");
                Console.WriteLine("{0,-" + col1 + "} | {1}", "", binaryPath + "platforms");
            }
            drawline();
        }
        /*
         *  Name: usage
         *  Type: Function
         *  Description: This function prints out the usage data
         *  Arguments: None
         */
        public static int usage()
        {
            Console.WriteLine("  Usage: searchsploit [options] term1 [term2] ... [termN]");
            Console.WriteLine("Example:");
            Console.WriteLine("  searchsploit afd windows local");
            Console.WriteLine("  searchsploit -t oracle windows");
            Console.WriteLine("  searchsploit --nmap NmapScan.xml");
            Console.WriteLine();
            Console.WriteLine("=========");
            Console.WriteLine(" Options ");
            Console.WriteLine("=========");
            Console.WriteLine("   -c, --case     Perform a case-sensitive search (Default is insensitive).");
            Console.WriteLine("   -h, --help     Show this help screen.");
            Console.WriteLine("   -t, --title    Search just the exploit title (Default is title AND the file's path).");
            Console.WriteLine("   -u, --update   Update exploit database from git.");
            Console.WriteLine("   -v, --verbose  Verbose output. Title lines are allowed to overflow their columns.");
            Console.WriteLine("   -w, --www      Show URLs to Exploit-DB.com rather than local path.");
            Console.WriteLine("       --colour   Disable colour highlighting.");
            Console.WriteLine("       --id       Display EDB-ID value rather than local path.");
            Console.WriteLine("       --nmap     Reads nmap's exported xml file to return vulnerabilities per host.");
            Console.WriteLine();
            Console.WriteLine("=======");
            Console.WriteLine(" Notes ");
            Console.WriteLine("=======");
            Console.WriteLine(" * Use any number of search terms, in any order.");
            Console.WriteLine(" * Search terms are not case sensitive, and order is irrelevant.");
            Console.WriteLine("   * Use '-c' if you wish to reduce results by case-sensitive searching.");
            Console.WriteLine("* Use '-t' to exclude the file's path to filter the search results.");
            Console.WriteLine("   * Could possibly remove false positives (especially when searching numbers).");
            Console.WriteLine(" * When updating from git or displaying help, search terms will be ignored.");
            Console.WriteLine();
            return 1;
        }
        /*
         *  Name: drawline
         *  Type: Function
         *  Description: This function does as the name describes, draw a line
         *  Arguments: None
         */
        public static void drawline()
        {
            for(int i = 0; i < Console.WindowWidth; i++)
            {
                Console.Write("-");
            }
        }
        /*
         *  Name: printColor
         *  Type: Function
         *  Description: This function will print the data with color highlighting based on the terms given
         *  Arguments: String line
         */
        public static void printColor(String line)
        {
            StringBuilder RegExTerms = new StringBuilder();
            MatchCollection Matches;
            for (int i = 0; i < terms.Count(); i++)
            {
                if (i == terms.Count() - 1)
                {
                    RegExTerms.Append(terms[i]);
                }
                else
                {
                    RegExTerms.Append(terms[i] + "|");
                }
            }
            if (caseSensitivity)
            {
                Matches = Regex.Matches(line, RegExTerms.ToString());
            }
            else
            {
                Matches = Regex.Matches(line, RegExTerms.ToString(), RegexOptions.IgnoreCase);
            }
            int start = 0;
            for (int x = 0; x < Matches.Count; x ++)
            {
                Match match = Matches[x];
                int Matchstart = match.Index;
                int Matchstop = match.Length;
                Console.Write(line.Substring(start, Matchstart - start));
                Console.ForegroundColor = ConsoleColor.Red;
                Console.Write(line.Substring(Matchstart, Matchstop));
                Console.ForegroundColor = ConsoleColor.Gray;
                start = Matchstart + Matchstop;
                if (x == Matches.Count - 1)
                {
                    Console.Write(line.Substring(start)+"\n");
                }
            }
        }
        /*
         *  Name: Search
         *  Type: Function
         *  Description: This fuction is used to search for the terms in everyline in the csv
         *  Arguments: None
         */
        public static void Search()
        {
            int counter = 0;
            string line;
            
            System.IO.StreamReader cvsFile = new System.IO.StreamReader(csvPath);
            while ((line = cvsFile.ReadLine()) != null)
            {
                if (line == "id,file,description,date,author,platform,type,port") { continue; }
                var items = line.Split(',');
                items[description] = items[description].Replace("\"", "");
                bool doesMatch = false;
                int matchCount = 0;
                string toMatch = items[description]+","+items[file];
                StringBuilder RegExTerms = new StringBuilder();
                MatchCollection Matches;
                if (!filepath)
                {
                    toMatch = items[description];
                }
                foreach (String term in terms)
                {
                    if (caseSensitivity)
                    {
                        if (Regex.IsMatch(toMatch, term))
                        {
                            matchCount++;
                        }
                    }
                    else
                    {
                        if (Regex.IsMatch(toMatch, term, RegexOptions.IgnoreCase))
                        {
                            matchCount++;
                        }
                    }
                }
                if (matchCount == terms.Count())
                {
                    doesMatch = true;
                    numberOfResults++;
                }
                if (doesMatch)
                {
                    if (!verbose)
                    {
                        if (items[description].Length > col1)
                        {
                            items[description] = items[description].Substring(0, col1);
                        }
                    }
                    if (weblink)
                    {
                        if (colour)
                        {
                            printColor(String.Format("{0,-" + col1 + "} | {1}", items[description], "https://www.exploit-db.com/exploits/" + items[file]));
                        }
                        else
                        {
                            Console.WriteLine("{0,-" + col1 + "} | {1}", items[description], "https://www.exploit-db.com/exploits/" + items[file]);
                        }
                    }
                    else if (edbid)
                    {
                        if (colour)
                        {
                            printColor(String.Format("{0,-" + col1 + "} | {1}", items[description], items[id]));
                        }
                        else
                        {
                            Console.WriteLine("{0,-" + col1 + "} | {1}", items[description], items[id]);
                        }
                    }
                    else
                    {
                        if (colour)
                        {
                            printColor(String.Format("{0,-" + col1 + "} | {1}", items[description], items[file]));
                        }
                        else
                        {
                            Console.WriteLine("{0,-" + col1 + "} | {1}", items[description], items[file]);
                        }
                    }
                }
                counter++;
            }
            cvsFile.Close();
            drawline();
        }
        /*
         *  Name: nmapParse
         *  Type: Function
         *  Description: This function will take in the path to the xmlfile and search for hosts and their associated services to then search for their vulnerabilities
         *  Arguments: String xmlfile
         */
        public static void nmapParse(string xmlfile)
        {
            string xmlFile = File.ReadAllText(xmlfile);
            XmlDocument xmldoc = new XmlDocument();
            xmldoc.LoadXml(xmlFile);
            XmlNodeList nodeList = xmldoc.GetElementsByTagName("host");
            String Product = "", Version = "";
            foreach (XmlElement node in nodeList)
            {
                if (node.HasChildNodes)
                {
                    foreach (XmlElement tmpAddressNode in node.GetElementsByTagName("address"))
                    {
                        if (tmpAddressNode.HasAttribute("addrtype") && tmpAddressNode.HasAttribute("addr"))
                        {
                            String tmpAddressTypeValue = tmpAddressNode.GetAttributeNode("addrtype").Value;
                            String tmpAddressValue = tmpAddressNode.GetAttributeNode("addr").Value;
                            if (tmpAddressTypeValue == "ipv4" && tmpAddressValue != "")
                            {
                                HostList.Add(new Host(tmpAddressValue));
                            }
                        }
                    }
                    foreach (XmlElement tmpServiceNode in node.GetElementsByTagName("service"))
                    {
                        if (tmpServiceNode.HasAttribute("product"))
                        {
                            Product = tmpServiceNode.GetAttributeNode("product").Value;
                        }
                        if (tmpServiceNode.HasAttribute("version"))
                        {
                            Version = tmpServiceNode.GetAttributeNode("version").Value;
                        }
                        if (Product == "" && Version == "")
                        {
                            continue;
                        }
                        else if (Product != "" && Version != "")
                        {
                            (HostList.Last()).ServicesAttribute.Add(new Service(Product, Version));
                            Product = "";
                            Version = "";
                        }
                        else
                        {
                            continue;
                        }
                    }
                }
            }
        }
        /*
         *  Name: Main
         *  Type: Function
         *  Description: This function is the first function to be ran in the program and handles the arguments and also handles the nmap file
         *  Arguments: string[] args
         */
        static int Main(string[] args)
        {
            Console.WriteLine();
            string tmparg = "";
            if (args.Length == 0)
            {
                return usage();
            }
            else
            {
                foreach (string arg in args)
                {
                    switch (arg)
                    {
                        case "-c":
                        case "--case":
                            caseSensitivity = true;
                            break;
                        case "-h":
                        case "--help":
                        case "?":
                            return usage();
                        case "-t":
                        case "--title":
                            filepath = false;
                            break;
                        case "-u":
                        case "--update":
                            return UpdateCSV();
                        case "-v":
                        case "--verbose":
                            verbose = true;
                            break;
                        case "-w":
                        case "--www":
                            weblink = true;
                            break;
                        case "--colour":
                        case "--color":
                            colour = false;
                            break;
                        case "--id":
                            edbid = true;
                            break;
                        case "--nmap":
                            nmap = true;
                            tmparg = arg;
                            break;
                        default:
                            if (arg.Contains("-"))
                            {
                                break;
                            }
                            terms.Add(arg);
                            break;
                    }
                }
            }
            if (nmap)
            {
                string filename = args[args.ToList().IndexOf(tmparg) + 1];
                if (File.Exists(filename))
                {
                    nmapParse(filename);
                }
                else
                {
                    Console.WriteLine("Error: File Could not be found.");
                    return 99;
                }
                if (weblink) { col2 = 45; }
                col1 = (Console.WindowWidth) - col2 - 1;

                printHeader();
                foreach (Host host in HostList)
                {
                    terms = new List<String>();
                    Console.WriteLine(host.AddressAttribute);
                    foreach (Service service in host.ServicesAttribute)
                    {
                        if (service.ProductAttribute != null)
                        {
                            if (service.ProductAttribute.Contains(" "))
                            {
                                foreach (String tmp in service.ProductAttribute.Split(' '))
                                {
                                    terms.Add(tmp);
                                }
                            }
                        }
                        if (service.VersionAttribute != null)
                        {
                            terms.Add(service.VersionAttribute);
                        }
                    }
                    Search();
                    drawline();
                }
            }
            else
            {
                if (weblink) { col2 = 45; }
                col1 = (Console.WindowWidth) - col2 - 1;

                printHeader();

                Search();

                Console.WriteLine("Total Results: " + numberOfResults + "\n");
            }
            return 0;
        }
    }
}
