using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Text.RegularExpressions;
using System.Xml;

// NOTE:
//   Exit code '0' means finished normally
//   Exit code '1' means finished help screen
//   Exit code '6' means updated from GitHub
//   Exit code '99' means error occured

namespace searchsploit
{
    /*
     *  Name: Service
     *  Type: Class
     *  Description: This class will be used to itemize a service when parsing nmap xml files
     *  Arguments: None
     */
    public class Service
    {
        // Service Class Attributes
        private String Product;
        private String Version;

        /*
         *  Name: Service
         *  Type: Constructor
         *  Description: This constructor is used to initiate a blank Service object
         *  Arguments: None
         */
        public Service()
        {
            this.Product = null;
            this.Version = null;
        }
        /*
         *  Name: Service
         *  Type: Constructor
         *  Description: This constructor is used to initiate a Service object with the Product and Version attributes being populated
         *  Arguments: String product, String version
         */
        public Service(String product, String version)
        {
            if (product == "")
            {
                this.Product = null;
            }
            else
            {
                this.Product = product;
            }
            if (version == "")
            {
                this.Version = null;
            }
            else
            {
                this.Version = version;
            }
        }

        public String ProductAttribute
        {
            get { return this.Product; }
            set { this.Product = value; }
        }
        public String VersionAttribute
        {
            get { return this.Version; }
            set { this.Version = value; }
        }
    }
    /*
     *  Name: Host
     *  Type: Class
     *  Description: This class will be used to itemize every host in an nmap xml file
     *  Arguments: None
     */
    public class Host
    {
        // Host Class Attributes
        private String Address;
        private List<Service> Services = new List<Service>();
        /*
         *  Name:
         *  Type:
         *  Description:
         *  Arguments:
         */
        public Host() { }
        /*
         *  Name:
         *  Type:
         *  Description:
         *  Arguments:
         */
        public Host(String address)
        {
            this.Address = address;
        }

        public String AddressAttribute
        {
            get { return this.Address; }
            set { this.Address = value; }
        }

        public List<Service> ServicesAttribute
        {
            get { return this.Services; }
            set { this.Services = value; }
        }
    }
    /*
     *  Name: Program
     *  Type: Class
     *  Description: This class will hold all the main functions utilized by the application
     *  Arguments: None
     */
    class Program
    {
        // Variables to be used in the Program Class
        static int id = 0, file = 1, description = 2, col2 = 35, col1, numberOfResults = 0;
        static bool caseSensitivity = false, verbose = false, weblink = false, edbid = false, colour = true, filepath = true, nmap = false;
        static String binaryPath = AppDomain.CurrentDomain.BaseDirectory, csvPath = binaryPath+"files.csv";
        static List<String> terms = new List<String>();
        static List<Host> HostList = new List<Host>();
        /*
         *  Name: UpdateCSV
         *  Type: Function
         *  Description: This function is intended to update the archive 
         *  Arguments: None
         */
        public static int UpdateCSV()
        {
            try {
                String URL = @"https://github.com/offensive-security/exploit-database/archive/master.zip";
                String FileName = @"master.zip";

                // Determine if certain directories and files exists. If they do, they are deleted
                if (Directory.Exists(binaryPath+"platforms")) { Directory.Delete(binaryPath + "platforms", true); }
                if (File.Exists(binaryPath + "files.csv")) { File.Delete(binaryPath + "files.csv"); }
                if (Directory.Exists(binaryPath + "exploit-database-master")) { Directory.Delete(binaryPath + "exploit-database-master", true); }
                if (File.Exists(binaryPath + "master.zip")) { File.Delete(binaryPath + "master.zip"); }

                // Initializing a WebClient object
                WebClient myWebClient = new WebClient();
                // Using the WebClient object to download the file.
                myWebClient.DownloadFile(URL, binaryPath+FileName);

                // Extract the contents from the downloaded zip file 
                ZipFile.ExtractToDirectory(binaryPath + FileName, binaryPath + ".");
                // Move the platform directory to the applications main directory
                Directory.Move(binaryPath + @"exploit-database-master\platforms", binaryPath + "platforms");
                // Move the main csv file to the applications main directory
                File.Move(binaryPath + @"exploit-database-master\files.csv", binaryPath + "files.csv");
                // Delete the extracted directory that as of now shouldn't contain anything of importance
                Directory.Delete(binaryPath + "exploit-database-master", true);
                // Delete the downloaded zip file
                File.Delete(binaryPath + "master.zip");

                // Prints text to let the user know the update finished successfully 
                Console.WriteLine("[*] Update finished.");
                return 6;
            }
            catch
            {
                // Prints text to let the user know that the update was unseccessful
                Console.WriteLine("Error... Update could not be completed");
                return 99;
            }
        }
        /*
         *  Name: printHeader
         *  Type: Function
         *  Description: This function prints the header of the application depending on the given command line arguments
         *  Arguments: None
         */
        public static void printHeader()
        {
            drawline(); // Function to draw a line
            // If the weblink command line arguemtn was used
            if (weblink)
            {
                // Print the first line of the header stating the information to be shown
                Console.WriteLine("{0,-" + col1 + "} | {1}", "Exploit Title", "URL");
                // Prints a blank line
                Console.WriteLine("{0,-" + col1 + "} | {1}", "", "");
            }
            else if (edbid)
            {
                // Print the first line of the header stating the information to be shown
                Console.WriteLine("{0,-" + col1 + "} | {1}", "Exploit Title", "EDB-ID");
                // Prints a blank line
                Console.WriteLine("{0,-" + col1 + "} | {1}", "", "");
            }
            else
            {
                // Print the first line of the header stating the information to be shown
                Console.WriteLine("{0,-" + col1 + "} | {1}", "Exploit Title", "Path");
                // Print the path to the binaries
                Console.WriteLine("{0,-" + col1 + "} | {1}", "", binaryPath + "platforms");
            }
            drawline(); // Function to draw a line
        }
        /*
         *  Name: usage
         *  Type: Function
         *  Description: This function prints out the usage data
         *  Arguments: None
         */
        public static int usage()
        {
            // All the lines below print a single line for the usage output
            Console.WriteLine("  Usage: searchsploit [options] term1 [term2] ... [termN]");
            Console.WriteLine("Example:");
            Console.WriteLine("  searchsploit afd windows local");
            Console.WriteLine("  searchsploit -t oracle windows");
            Console.WriteLine("  searchsploit --nmap NmapScan.xml");
            Console.WriteLine();
            Console.WriteLine("=========");
            Console.WriteLine(" Options ");
            Console.WriteLine("=========");
            Console.WriteLine("   -c, --case     Perform a case-sensitive search (Default is insensitive).");
            Console.WriteLine("   -h, --help     Show this help screen.");
            Console.WriteLine("   -t, --title    Search just the exploit title (Default is title AND the file's path).");
            Console.WriteLine("   -u, --update   Update exploit database from git.");
            Console.WriteLine("   -v, --verbose  Verbose output. Title lines are allowed to overflow their columns.");
            Console.WriteLine("   -w, --www      Show URLs to Exploit-DB.com rather than local path.");
            Console.WriteLine("       --colour   Disable colour highlighting.");
            Console.WriteLine("       --id       Display EDB-ID value rather than local path.");
            Console.WriteLine("       --nmap     Reads nmap's exported xml file to return vulnerabilities per host.");
            Console.WriteLine();
            Console.WriteLine("=======");
            Console.WriteLine(" Notes ");
            Console.WriteLine("=======");
            Console.WriteLine(" * Use any number of search terms, in any order.");
            Console.WriteLine(" * Search terms are not case sensitive, and order is irrelevant.");
            Console.WriteLine("   * Use '-c' if you wish to reduce results by case-sensitive searching.");
            Console.WriteLine("* Use '-t' to exclude the file's path to filter the search results.");
            Console.WriteLine("   * Could possibly remove false positives (especially when searching numbers).");
            Console.WriteLine(" * When updating from git or displaying help, search terms will be ignored.");
            Console.WriteLine();
            return 1;
        }
        /*
         *  Name: drawline
         *  Type: Function
         *  Description: This function does as the name describes, draw a line
         *  Arguments: None
         */
        public static void drawline()
        {
            // For loop goes for the width of the console window and prints a dash
            for(int i = 0; i < Console.WindowWidth; i++)
            {
                Console.Write("-");
            }
        }
        /*
         *  Name: printColor
         *  Type: Function
         *  Description: This function will print the data with color highlighting based on the terms given
         *  Arguments: String line
         */
        public static void printColor(String line)
        {
            // Initiate variables to be used later on in the function
            StringBuilder RegExTerms = new StringBuilder();
            MatchCollection Matches;
            for (int i = 0; i < terms.Count(); i++) // Iterate thru the terms to create 
            {
                if (i == terms.Count() - 1)
                {
                    RegExTerms.Append(terms[i]);
                }
                else
                {
                    RegExTerms.Append(terms[i] + "|");
                }
            }
            if (caseSensitivity) // If case sensativity is wanted
            {
                Matches = Regex.Matches(line, RegExTerms.ToString()); // Find Matches
            }
            else
            {
                Matches = Regex.Matches(line, RegExTerms.ToString(), RegexOptions.IgnoreCase); // Find Matches with case insensativity
            }
            int start = 0; // Variable to identify the start point
            for (int x = 0; x < Matches.Count; x ++) // Iterate thru matches
            {
                Match match = Matches[x]; // Get the first Match object
                int Matchstart = match.Index; // Get the starting index
                int Matchstop = match.Length; // Get the length of the match
                Console.Write(line.Substring(start, Matchstart - start)); // Print substring without color
                Console.ForegroundColor = ConsoleColor.Red; // Change text color to red
                Console.Write(line.Substring(Matchstart, Matchstop)); // Print substring with red color
                Console.ForegroundColor = ConsoleColor.Gray; // Change text color to gray
                start = Matchstart + Matchstop; // Change the start of the text
                if (x == Matches.Count - 1) // Check to see if its the end of the text
                {
                    Console.Write(line.Substring(start)+"\n"); // Print the rest of the line of text
                }
            }
        }
        /*
         *  Name: Search
         *  Type: Function
         *  Description: This fuction is used to search for the terms in everyline in the csv
         *  Arguments: None
         */
        public static void Search()
        {
            // Variables to be used in the rest of the function
            int counter = 0;
            string line;
            
            System.IO.StreamReader cvsFile = new System.IO.StreamReader(csvPath); // Open CSV file
            while ((line = cvsFile.ReadLine()) != null) // Iterate thru each line of of the CSV file
            {
                if (line == "id,file,description,date,author,platform,type,port") { continue; } // If statement to determine if its the first line of the CSV
                var items = line.Split(','); // Split the line by comma into an array of items
                items[description] = items[description].Replace("\"", ""); // Get the description
                bool doesMatch = false; // bool to see if there is a batch
                int matchCount = 0; // the count for matches
                string toMatch = items[description]+","+items[file]; // String to match to
                StringBuilder RegExTerms = new StringBuilder(); // Create a StringBuilder object to be used as regular expression to be evaluated
                if (!filepath) // If the filepath command line argument is given
                {
                    toMatch = items[description]; // change the variable to be matched to only include the description
                }
                foreach (String term in terms) // Iterate thru the terms
                {
                    if (caseSensitivity) // if case sensitivity is wanted
                    {
                        if (Regex.IsMatch(toMatch, term)) // Determine if there is a match
                        {
                            matchCount++; // increment the count for matches
                        }
                    }
                    else
                    {
                        if (Regex.IsMatch(toMatch, term, RegexOptions.IgnoreCase)) // Determine if there is a match that is case insensitive
                        {
                            matchCount++; // Increment the count for matches
                        }
                    }
                }
                if (matchCount == terms.Count()) // If the match count and term count equal
                {
                    doesMatch = true; // change doesMatch to true
                    numberOfResults++; // increment the number of results
                }
                if (doesMatch) // If doesMatch is true
                {
                    if (!verbose) // If verbose command line argument is used
                    {
                        if (items[description].Length > col1)
                        {
                            items[description] = items[description].Substring(0, col1);
                        }
                    }
                    if (weblink) // If weblink command line argument is used
                    {
                        if (colour) // If color is wanted
                        {
                            printColor(String.Format("{0,-" + col1 + "} | {1}", items[description], "https://www.exploit-db.com/exploits/" + items[file])); // Print description and url to item
                        }
                        else
                        {
                            Console.WriteLine("{0,-" + col1 + "} | {1}", items[description], "https://www.exploit-db.com/exploits/" + items[file]); // Print description and url to item
                        }
                    }
                    else if (edbid) // Else if edbid command line argument is used
                    {
                        if (colour) // If color is wanted
                        {
                            printColor(String.Format("{0,-" + col1 + "} | {1}", items[description], items[id])); // Print description and id
                        }
                        else
                        {
                            Console.WriteLine("{0,-" + col1 + "} | {1}", items[description], items[id]); // Print description and id
                        }
                    }
                    else
                    {
                        if (colour) // If color is wanted
                        {
                            printColor(String.Format("{0,-" + col1 + "} | {1}", items[description], items[file])); // Print description and file
                        }
                        else
                        {
                            Console.WriteLine("{0,-" + col1 + "} | {1}", items[description], items[file]); // Print description and file
                        }
                    }
                }
                counter++;
            }
            cvsFile.Close();
            drawline();
        }
        /*
         *  Name: nmapParse
         *  Type: Function
         *  Description: This function will take in the path to the xmlfile and search for hosts and their associated services to then search for their vulnerabilities
         *  Arguments: String xmlfile
         */
        public static void nmapParse(string xmlfile)
        { 
            // Variables to be used for nmap parsing
            string xmlFile = File.ReadAllText(xmlfile);
            XmlDocument xmldoc = new XmlDocument();
            xmldoc.LoadXml(xmlFile);
            XmlNodeList nodeList = xmldoc.GetElementsByTagName("host");
            String Product = "", Version = "";

            // Iterate thru all host nodes
            foreach (XmlElement node in nodeList)
            {
                if (node.HasChildNodes) // If the host has child nodes
                {
                    foreach (XmlElement tmpAddressNode in node.GetElementsByTagName("address")) //Iterate thru all host's address nodes
                    {
                        if (tmpAddressNode.HasAttribute("addrtype") && tmpAddressNode.HasAttribute("addr")) // If the address node contains the addrtype and addr attribute
                        {
                            String tmpAddressTypeValue = tmpAddressNode.GetAttributeNode("addrtype").Value; // Get the addrtype attribute value
                            String tmpAddressValue = tmpAddressNode.GetAttributeNode("addr").Value; // Get the addr attribute value
                            if (tmpAddressTypeValue == "ipv4" && tmpAddressValue != "") // if the address type is ipv4 and value isnt empty
                            {
                                HostList.Add(new Host(tmpAddressValue)); // Create a new Host object to the HostList list.
                            }
                        }
                    }
                    foreach (XmlElement tmpServiceNode in node.GetElementsByTagName("service")) // Iterate thru services inside the host node
                    {
                        if (tmpServiceNode.HasAttribute("product")) // if service node has product attribute
                        {
                            Product = tmpServiceNode.GetAttributeNode("product").Value; // get the product attribute value
                        }
                        if (tmpServiceNode.HasAttribute("version")) // if service node has version attribute
                        {
                            Version = tmpServiceNode.GetAttributeNode("version").Value; // get the version attribute value
                        }
                        if (Product == "" && Version == "") // if both Product and Version are empty continue onto the next service node
                        {
                            continue;
                        }
                        else if (Product != "" && Version != "") // if both product and version are not empty
                        {
                            (HostList.Last()).ServicesAttribute.Add(new Service(Product, Version)); // Get the last Host node and add the Service to its ServicesAttribute
                            Product = ""; // Clear the product variable
                            Version = ""; // Clear the version variable
                        }
                        else
                        {
                            continue;
                        }
                    }
                }
            }
        }
        /*
         *  Name: Main
         *  Type: Function
         *  Description: This function is the first function to be ran in the program and handles the arguments and also handles the nmap file
         *  Arguments: string[] args
         */
        static int Main(string[] args)
        {
            Console.WriteLine(); // Print an empty line
            string tmparg = ""; // string to temporary use
            if (args.Length == 0) // If argument count equals 0
            {
                return usage(); // return the usage prompt
            }
            else
            {
                foreach (string arg in args) // Iterate thru the arguments
                {
                    //For more description on the arguments view the usage function
                    switch (arg) // Switch statement for each argument
                    {
                        case "-c":
                        case "--case":
                            caseSensitivity = true;
                            break;
                        case "-h":
                        case "--help":
                        case "?":
                            return usage();
                        case "-t":
                        case "--title":
                            filepath = false;
                            break;
                        case "-u":
                        case "--update":
                            return UpdateCSV();
                        case "-v":
                        case "--verbose":
                            verbose = true;
                            break;
                        case "-w":
                        case "--www":
                            weblink = true;
                            break;
                        case "--colour":
                        case "--color":
                            colour = false;
                            break;
                        case "--id":
                            edbid = true;
                            break;
                        case "--nmap":
                            nmap = true;
                            tmparg = arg;
                            break;
                        default:
                            if (arg.Contains("-"))
                            {
                                break;
                            }
                            terms.Add(arg);
                            break;
                    }
                }
            }
            if (nmap) // if nmap is true
            {
                string filename = args[args.ToList().IndexOf(tmparg) + 1]; // Get the next argument
                if (File.Exists(filename)) // Check to see if the file exists
                {
                    nmapParse(filename); // Run the file name thru nmapParser function
                }
                else
                {
                    Console.WriteLine("Error: File Could not be found."); // If file doesnt exist print error message
                    return 99;
                }
                if (weblink) { col2 = 45; } //if weblink command line argument is used change the second column width to 45
                col1 = (Console.WindowWidth) - col2 - 1; // Calculate the first columns length

                printHeader(); // Print the header
                foreach (Host host in HostList) // Iterate thru the hosts in the hostlist
                {
                    terms = new List<String>(); // create a list of strings
                    Console.WriteLine(host.AddressAttribute); // print out the hosts ipv4 address
                    foreach (Service service in host.ServicesAttribute) // Iterate thru the services of host
                    {
                        if (service.ProductAttribute != null) // if the services product attribute isnt null
                        {
                            if (service.ProductAttribute.Contains(" ")) // check to see if product attribute contains multiple words
                            {
                                foreach (String tmp in service.ProductAttribute.Split(' ')) // iterate thru all words
                                {
                                    terms.Add(tmp); // add word to terms list
                                }
                            }
                        }
                        if (service.VersionAttribute != null) // if services version attribute isnt null
                        {
                            terms.Add(service.VersionAttribute); // and the version number to terms list
                        }
                    }
                    Search(); // Perform Search
                    drawline(); // Draw line
                }
            }
            else
            {
                if (weblink) { col2 = 45; } //if weblink command line argument is used change the second column width to 45
                col1 = (Console.WindowWidth) - col2 - 1; // Calculate the first columns length

                printHeader(); // Print header

                Search(); // Perform Search

                Console.WriteLine("Total Results: " + numberOfResults + "\n"); // Print number of results
            }
            return 0;
        }
    }
}
